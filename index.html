<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>IPCluster – Scaling Zopim’s frontend node servers</title>
    <link rel="stylesheet" type="text/css" href="build/build.css">
  </head>
  <body>
    <article>
      <section>
        <h1>Scaling Zopim’s frontend node servers</h1>
        <h2>Enterprise Infrastructure and IPCluster</h2>
      </section>
      <section>
        <h2>Outline</h2>
        <ul>
          <li>Scaling</li>
          <li>IPCluster</li>
        </ul>
      </section>
      <section>
        <h2>Typical NodeJS Project Lifecycle</h2>
        <h3>NodeJS starts fast out of the gate, but multi-core/-node and memory leaks can be a deal breaker</h3>
      </section>
      <section>
        <h2>"Enterprise" NodeJS Scaling</h2>
        <h3>Of SSL terminators, load balancers, firewalls and DDoS mitigation</h3>
      </section>
      <section>
        <h2>What We Tried</h2>
        <ul>
          <li>cluster module</li>
          <li>HA Proxy</li>
          <li>stud</li>
          <li>nginx WebSockets</li>
        </ul>
      </section>
      <section>
        <h2>Capturing client IP address</h2>
        <pre><code class="language-javascript">function attach(http_server) {
  // cache and clean up listeners
  var old_listeners = http_server.listeners('connection'),
  length = old_listeners.length, self = this;
  
  http_server.removeAllListeners('connection');
  http_server.on('connection', function(connection) {
    connection.on('close', clean);
    connection.on('error', function() { connection.destroy(); clean() });
    connection.on('data', intercept_IP);
    
    function intercept_IP(buffer) {
      if (!buffer.length) return;
      
      var family = buffer[0], f_length = FAMILY_LENGTH[family], remoteIP;
      
      if (!f_length) return;
      
      remoteIP = Array.prototype.slice.call(buffer, 1, 1 + f_length);
      connection.studRemoteAddress = stringifyIP(remoteIP);
      connection.__defineGetter__('remoteAddress', returnStudRemoteAddress);
      connection.encrypted = true;
      
      if (buffer.length > f_length + 1)
        pass_through(buffer.slice(1 + f_length));
      else
        connection.on('data', pass_through);
    }
    
    function pass_through(residue) {
      clean();
      
      for (var i = 0; i < length; i++)
      old_listeners[i].call(http_server, connection);
      
      connection.on('error', function self(e) {
        connection.removeListener('error', self);
        console.log(e.stack);
      });
      
      connection.emit('data', residue);
    }
    
    function clean() { connection.removeAllListeners() }
  });
}

function returnStudRemoteAddress() { return this.studRemoteAddress }
</code></pre>
      </section>
      <section>
        <h2>Bare-metal Cluster?</h2>
        <h3>What if there was a better way?</h3>
      </section>
      <section>
        <h2>Netmask Primer</h2>
      </section>
      <section>
        <h2>Abusing Netmask Matching</h2>
      </section>
      <section>
        <h2>Introducing IPCluster</h2>
        <h3>Eschew "Enterprise” topologies, embrace a bare-metal topology</h3>
      </section>
      <section>
        <h2>IPCluster Features</h2>
        <ul>
          <li>Multicore</li>
          <li>Graceful restarts (limit memory usage)</li>
          <li>Soft Reload (new code without disconnecting existing clients)</li>
          <li>Bare Metal (direct access to socket, reliable ‘drain’ events)</li>
        </ul>
      </section>
      <section>
        <h2>IPCluster – Future</h2>
        <h3>Track down memory leaks with automatic heap diff’ing, Management GUI</h3>
      </section>
      <section>
        <h2>That's all folks!</h2>
      </section>
    </article>
    <script src="build/build.js"></script>
  </body>
</html>